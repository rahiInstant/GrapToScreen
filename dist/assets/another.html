<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta name="theme-color" content="#000000" />
    <title>Vanilla Flow</title>
    <style>
      body {
        margin: 0;
        padding: 0;
        font-family: Arial, sans-serif;
        background-color: #2d2e2e;
        color: #e7ebf3;
        overflow: hidden;
      }
      
      #canvas-container {
        position: absolute;
        width: 100%;
        height: 100%;
        overflow: hidden;
      }
      
      #canvas {
        position: absolute;
        width: 100%;
        height: 100%;
        background-size: 20px 20px;
        background-image: radial-gradient(circle, #a5a5a5 0.1px, transparent 1px);
        transform-origin: 0 0;
      }
      
      .node {
        position: absolute;
        width: 100px;
        height: 100px;
        background-color: #414244;
        border: 2px solid #c3c9d5;
        border-radius: 10px;
        display: flex;
        justify-content: center;
        align-items: center;
        cursor: move;
        -webkit-user-select: none;
        user-select: none;
      }
      
      .node.selected {
        outline: 8px solid #626262;
      }
      
      .node-title {
        position: absolute;
        bottom: -30px;
        font-weight: 600;
        color: #f1f3ec;
        font-size: 1rem;
        text-align: center;
        width: 100%;
      }
      
      .port {
        position: absolute;
        width: 12px;
        height: 12px;
        background-color: #58abff;
        border-radius: 50%;
      }
      
      .input-port {
        top: 50%;
        left: -6px;
        transform: translateY(-50%);
      }
      
      .output-port {
        top: 50%;
        right: -6px;
        transform: translateY(-50%);
      }
      
      .connection {
        position: absolute;
        pointer-events: none;
        z-index: -1;
      }
      
      #sidebar {
        position: fixed;
        top: 0;
        left: 0;
        width: 60px;
        height: 100%;
        background-color: #353535;
        transition: width 0.3s;
        overflow: hidden;
        z-index: 100;
      }
      
      #sidebar.expanded {
        width: 250px;
      }
      
      #add-node-btn {
        width: 40px;
        height: 40px;
        margin: 10px;
        background-color: #58abff;
        border: none;
        border-radius: 5px;
        color: white;
        font-size: 24px;
        cursor: pointer;
      }
      
      #node-list {
        display: none;
        padding: 10px;
      }
      
      #sidebar.expanded #node-list {
        display: block;
      }
      
      .node-template {
        padding: 10px;
        margin: 5px 0;
        background-color: #414244;
        border-radius: 5px;
        cursor: pointer;
      }
      
      .node-template:hover {
        background-color: #505154;
      }
      
      #zoom-controls {
        position: fixed;
        bottom: 20px;
        left: 70px;
        display: flex;
        gap: 10px;
        z-index: 100;
      }
      
      .zoom-btn {
        width: 40px;
        height: 40px;
        background-color: #353535;
        border: 1px solid #e7ebf3;
        border-radius: 5px;
        color: #e7ebf3;
        font-size: 16px;
        cursor: pointer;
      }
    </style>
  </head>
  <body>
    <div id="canvas-container">
      <div id="canvas"></div>
    </div>
    
    <div id="sidebar">
      <button id="add-node-btn">+</button>
      <div id="node-list">
        <h3>Add Node</h3>
        <div class="node-template" data-type="process">Process Node</div>
        <div class="node-template" data-type="decision">Decision Node</div>
        <div class="node-template" data-type="input">Input Node</div>
        <div class="node-template" data-type="output">Output Node</div>
      </div>
    </div>
    
    <div id="zoom-controls">
      <button class="zoom-btn" id="zoom-in">+</button>
      <button class="zoom-btn" id="zoom-out">-</button>
      <button class="zoom-btn" id="zoom-fit">Fit</button>
      <button class="zoom-btn" id="zoom-reset">R</button>
    </div>
    
    <script>
      document.addEventListener('DOMContentLoaded', function() {
        // Main elements
        const canvas = document.getElementById('canvas');
        const sidebar = document.getElementById('sidebar');
        const addNodeBtn = document.getElementById('add-node-btn');
        const nodeList = document.getElementById('node-list');
        const nodeTemplates = document.querySelectorAll('.node-template');
        
        // Zoom controls
        const zoomInBtn = document.getElementById('zoom-in');
        const zoomOutBtn = document.getElementById('zoom-out');
        const zoomFitBtn = document.getElementById('zoom-fit');
        const zoomResetBtn = document.getElementById('zoom-reset');
        
        // State variables
        let nodes = [];
        let connections = [];
        let nextNodeId = 1;
        let selectedNode = null;
        let draggedNode = null;
        let dragOffset = { x: 0, y: 0 };
        let isPanning = false;
        let panStart = { x: 0, y: 0 };
        let scale = 1;
        let translate = { x: 0, y: 0 };
        let connectingPort = null;
        
        // Toggle sidebar
        addNodeBtn.addEventListener('click', function() {
          sidebar.classList.toggle('expanded');
        });
        
        // Create a new node from template
        nodeTemplates.forEach(template => {
          template.addEventListener('click', function() {
            const type = this.getAttribute('data-type');
            createNode(type, 100, 100);
            sidebar.classList.remove('expanded');
          });
        });
        
        // Create a node
        function createNode(type, x, y) {
          const id = nextNodeId++;
          const node = document.createElement('div');
          node.className = 'node';
          node.id = `node-${id}`;
          node.setAttribute('data-id', id);
          node.setAttribute('data-type', type);
          
          // Position relative to canvas and transform
          const canvasRect = canvas.getBoundingClientRect();
          const nodeX = (x - translate.x) / scale;
          const nodeY = (y - translate.y) / scale;
          
          node.style.left = `${nodeX}px`;
          node.style.top = `${nodeY}px`;
          
          // Add title
          const title = document.createElement('div');
          title.className = 'node-title';
          title.textContent = `${type.charAt(0).toUpperCase() + type.slice(1)} ${id}`;
          node.appendChild(title);
          
          // Add ports
          const inputPort = document.createElement('div');
          inputPort.className = 'port input-port';
          inputPort.setAttribute('data-port-type', 'input');
          node.appendChild(inputPort);
          
          const outputPort = document.createElement('div');
          outputPort.className = 'port output-port';
          outputPort.setAttribute('data-port-type', 'output');
          node.appendChild(outputPort);
          
          canvas.appendChild(node);
          
          // Store node data
          nodes.push({
            id,
            element: node,
            type,
            x: nodeX,
            y: nodeY
          });
          
          // Add event listeners
          setupNodeEvents(node);
          
          return node;
        }
        
        // Setup node event listeners
        function setupNodeEvents(node) {
          node.addEventListener('mousedown', onNodeMouseDown);
          
          // Port connection handling
          const ports = node.querySelectorAll('.port');
          ports.forEach(port => {
            port.addEventListener('mousedown', function(e) {
              e.stopPropagation();
              
              if (port.getAttribute('data-port-type') === 'output') {
                connectingPort = {
                  node: node,
                  port: port,
                  x: e.clientX,
                  y: e.clientY
                };
                
                // Create temporary connection line
                const tempConnection = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
                tempConnection.className = 'connection';
                tempConnection.id = 'temp-connection';
                tempConnection.style.position = 'absolute';
                tempConnection.style.top = '0';
                tempConnection.style.left = '0';
                tempConnection.style.width = '100%';
                tempConnection.style.height = '100%';
                tempConnection.style.pointerEvents = 'none';
                tempConnection.innerHTML = `<path d="" stroke="#58abff" stroke-width="2" fill="none"/>`;
                canvas.appendChild(tempConnection);
              }
            });
            
            if (port.getAttribute('data-port-type') === 'input') {
              port.addEventListener('mouseup', function(e) {
                if (connectingPort) {
                  const sourceNode = connectingPort.node;
                  const targetNode = node;
                  
                  if (sourceNode !== targetNode) {
                    createConnection(
                      sourceNode.getAttribute('data-id'),
                      targetNode.getAttribute('data-id')
                    );
                  }
                  
                  // Remove temporary connection
                  const tempConnection = document.getElementById('temp-connection');
                  if (tempConnection) {
                    tempConnection.remove();
                  }
                  
                  connectingPort = null;
                }
              });
            }
          });
        }
        
        // Handle node selection and dragging
        function onNodeMouseDown(e) {
          e.stopPropagation();
          
          // Select node
          if (selectedNode) {
            selectedNode.classList.remove('selected');
          }
          
          selectedNode = this;
          selectedNode.classList.add('selected');
          
          // Prepare for dragging
          draggedNode = this;
          const rect = draggedNode.getBoundingClientRect();
          dragOffset = {
            x: e.clientX - rect.left,
            y: e.clientY - rect.top
          };
          
          // Bring to front
          canvas.appendChild(draggedNode);
        }
        
        // Create a connection between nodes
        function createConnection(sourceId, targetId) {
          const connection = {
            id: `connection-${sourceId}-${targetId}`,
            sourceId,
            targetId
          };
          
          connections.push(connection);
          drawConnections();
        }
        
        // Draw all connections
        function drawConnections() {
          // Remove all existing connection SVGs
          document.querySelectorAll('.connection:not(#temp-connection)').forEach(el => el.remove());
          
          // Create new SVG for all connections
          const connectionsSvg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
          connectionsSvg.className = 'connection';
          connectionsSvg.style.position = 'absolute';
          connectionsSvg.style.top = '0';
          connectionsSvg.style.left = '0';
          connectionsSvg.style.width = '100%';
          connectionsSvg.style.height = '100%';
          connectionsSvg.style.pointerEvents = 'none';
          
          let pathsHtml = '';
          
          connections.forEach(conn => {
            const sourceNode = document.querySelector(`[data-id="${conn.sourceId}"]`);
            const targetNode = document.querySelector(`[data-id="${conn.targetId}"]`);
            
            if (sourceNode && targetNode) {
              const sourcePort = sourceNode.querySelector('.output-port');
              const targetPort = targetNode.querySelector('.input-port');
              
              const sourceRect = sourcePort.getBoundingClientRect();
              const targetRect = targetPort.getBoundingClientRect();
              const canvasRect = canvas.getBoundingClientRect();
              
              const x1 = (sourceRect.left + sourceRect.width/2 - canvasRect.left) / scale;
              const y1 = (sourceRect.top + sourceRect.height/2 - canvasRect.top) / scale;
              const x2 = (targetRect.left + targetRect.width/2 - canvasRect.left) / scale;
              const y2 = (targetRect.top + targetRect.height/2 - canvasRect.top) / scale;
              
              // Create bezier curve
              const dx = Math.abs(x2 - x1) * 0.5;
              const path = `M ${x1} ${y1} C ${x1 + dx} ${y1}, ${x2 - dx} ${y2}, ${x2} ${y2}`;
              
              pathsHtml += `<path d="${path}" stroke="#58abff" stroke-width="2" fill="none"/>`;
            }
          });
          
          connectionsSvg.innerHTML = pathsHtml;
          canvas.appendChild(connectionsSvg);
        }
        
        // Update temporary connection while dragging
        function updateTempConnection(e) {
          if (!connectingPort) return;
          
          const tempConnection = document.getElementById('temp-connection');
          if (!tempConnection) return;
          
          const sourcePort = connectingPort.port;
          const sourceRect = sourcePort.getBoundingClientRect();
          const canvasRect = canvas.getBoundingClientRect();
          
          const x1 = (sourceRect.left + sourceRect.width/2 - canvasRect.left) / scale;
          const y1 = (sourceRect.top + sourceRect.height/2 - canvasRect.top) / scale;
          const x2 = (e.clientX - canvasRect.left) / scale;
          const y2 = (e.clientY - canvasRect.top) / scale;
          
          // Create bezier curve
          const dx = Math.abs(x2 - x1) * 0.5;
          const path = `M ${x1} ${y1} C ${x1 + dx} ${y1}, ${x2 - dx} ${y2}, ${x2} ${y2}`;
          
          tempConnection.querySelector('path').setAttribute('d', path);
        }
        
        // Apply transform to canvas
        function applyTransform() {
          canvas.style.transform = `translate(${translate.x}px, ${translate.y}px) scale(${scale})`;
        }
        
        // Mouse event handlers
        canvas.addEventListener('mousedown', function(e) {
          if (e.target === canvas) {
            isPanning = true;
            panStart = { x: e.clientX - translate.x, y: e.clientY - translate.y };
            canvas.style.cursor = 'grabbing';
          }
        });
        
        document.addEventListener('mousemove', function(e) {
          // Handle node dragging
          if (draggedNode) {
            const canvasRect = canvas.getBoundingClientRect();
            const x = (e.clientX - canvasRect.left - dragOffset.x) / scale;
            const y = (e.clientY - canvasRect.top - dragOffset.y) / scale;
            
            draggedNode.style.left = `${x}px`;
            draggedNode.style.top = `${y}px`;
            
            // Update node data
            const nodeId = draggedNode.getAttribute('data-id');
            const nodeData = nodes.find(n => n.id == nodeId);
            if (nodeData) {
              nodeData.x = x;
              nodeData.y = y;
            }
            
            drawConnections();
          }
          
          // Handle canvas panning
          if (isPanning) {
            translate.x = e.clientX - panStart.x;
            translate.y = e.clientY - panStart.y;
            applyTransform();
          }
          
          // Update temporary connection
          updateTempConnection(e);
        });
        
        document.addEventListener('mouseup', function() {
          draggedNode = null;
          isPanning = false;
          canvas.style.cursor = 'default';
          
          // Clear connecting port if not connected
          if (connectingPort) {
            const tempConnection = document.getElementById('temp-connection');
            if (tempConnection) {
              tempConnection.remove();
            }
            connectingPort = null;
          }
        });
        
        // Zoom controls
        zoomInBtn.addEventListener('click', function() {
          scale = Math.min(scale * 1.2, 3);
          applyTransform();
          drawConnections();
        });
        
        zoomOutBtn.addEventListener('click', function() {
          scale = Math.max(scale / 1.2, 0.3);
          applyTransform();
          drawConnections();
        });
        
        zoomResetBtn.addEventListener('click', function() {
          scale = 1;
          translate = { x: 0, y: 0 };
          applyTransform();
          drawConnections();
        });
        
        zoomFitBtn.addEventListener('click', function() {
          if (nodes.length === 0) return;
          
          // Find bounds of all nodes
          let minX = Infinity, minY = Infinity;
          let maxX = -Infinity, maxY = -Infinity;
          
          nodes.forEach(node => {
            const rect = node.element.getBoundingClientRect();
            minX = Math.min(minX, node.x);
            minY = Math.min(minY, node.y);
            maxX = Math.max(maxX, node.x + rect.width / scale);
            maxY = Math.max(maxY, node.y + rect.height / scale);
          });
          
          const padding = 50;
          const canvasRect = canvas.getBoundingClientRect();
          const canvasWidth = canvasRect.width;
          const canvasHeight = canvasRect.height;
          
          const contentWidth = maxX - minX + padding * 2;
          const contentHeight = maxY - minY + padding * 2;
          
          scale = Math.min(
            canvasWidth / contentWidth,
            canvasHeight / contentHeight,
            1
          );
          
          const centerX = minX + contentWidth / 2;
          const centerY = minY + contentHeight / 2;
          
          translate.x = canvasWidth / 2 - centerX * scale;
          translate.y = canvasHeight / 2 - centerY * scale;
          
          applyTransform();
          drawConnections();
        });
        
        // Mouse wheel zoom
        canvas.addEventListener('wheel', function(e) {
          e.preventDefault();
          
          const delta = -e.deltaY * 0.001;
          const newScale = Math.max(0.3, Math.min(3, scale * (1 + delta)));
          
          // Zoom centered on mouse position
          const rect = canvas.getBoundingClientRect();
          const mouseX = e.clientX - rect.left;
          const mouseY = e.clientY - rect.top;
          
          const oldScale = scale;
          scale = newScale;
          
          translate.x = mouseX - (mouseX - translate.x) * (scale / oldScale);
          translate.y = mouseY - (mouseY - translate.y) * (scale / oldScale);
          
          applyTransform();
          drawConnections();
        }, { passive: false });
        
        // Initialize with a couple of nodes
        setTimeout(() => {
          createNode('process', 200, 200);
          createNode('decision', 400, 300);
        }, 100);
      });
    </script>
  </body>
</html>